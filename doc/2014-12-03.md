# 12/02議事録

## 前回までの疑問と回答

### 式年遷宮

伊勢神宮の定期的な建て替えの事。技術の伝承の意図がある。

プロジェクトは定期的にフルスクラッチされるべきであるとのたとえに用いた。

### immutableとconstが同時に存在するのか

YES

+ immutable: いつ参照しても変化することがないことが保証された値
+ const: *自分が*書き換えないと主張する値

違いは参照で渡された場合の挙動。
+ immutableは参照にされても書き換えできない。
+ constは参照にした上で自分が書き換えないだけ。atomic参照にはロックが必要。

### `f(int x, int y)->(int)`が実態は`f(var (int&, int&) xy)->(int)`なのは非直感的では

A: 問題点がいくつもある

1. Tuple->Tupleを関数とみなそうとしていること。
2. 関数宣言と変数宣言が似ている。
3. でも引数はデフォルトで参照としたい。
	 初学者が気軽に使うときは参照渡しとなるようにしたい。

## 参照とはなんなのか(前章質問の第三)

	int &a = 0; // これを許可するのか
	int &b = a;

関数の引数に与える場合でも、文脈がわかれば型修飾子で実装を区別することも可能ではないかとする意見が出たが、仕様の策定が難しいため不採用に。

参照型への直接のリテラル代入も禁止の方針に。

## 型修飾子について

値の変更可能性についてと参照についての指定にそれぞれ存在。

+ 変更可能性について
	- `immutable`
		
		変更が行われないことが保証された値。別スレッドによる変更も許可されない。
	- `readonly`(`const`)
		
		このスコープ内では変更しない。別スレッドなどではreadonly指定がない場合は実行時に変更される可能性がある。
	- `mutable`
		
		変更可能。
+ 参照について
	- `value`
  
		値渡し
	- `ref`
		
		参照渡し

ポインタは独立した型で型修飾子ではないものとする。

## 関数はtuple->tupleとは扱わない

以前の議論では関数シグニチャの`(arg)->(ret)`は`tuple`を引数に取り、`tuple`を返り値にすることにしたが、質問にあった以下の問題を考慮し、廃止とする。

	f(int x, int y)->(int) === f(var (int&, int&) xy)->(int)

特に`f(x, y)`というプログラムが`f(mk_tuple(&x, &y))`と解釈されることは問題である。これでは引数が`tuple`である事と不一致である。

よって関数はn個の引数を取り、一つの値を返すものとして扱う。

## RVOの前提化

+ RVO
	
	return value optimization.

	返り値へのポインタを暗黙の引数として渡すことでコピーの回数を削減する最適化

klangでは導入は前提とする。

プログラマには返り値で値を返す事に推奨する。(tuple返しなど)

## コンパイル時のファイル構造について

### 中間オブジェクトと最適化

+ 議題: linkerによる最適化は信用しない。

	==> アセンブル前にリンカレベルの(ファイルを越えての)最適化を行いたい

+ 案: .kファイルを一度に統合し、.oファイル形式のリンクという形を廃止
	
	.k *=> .ll ==> a.out

+ なぜ: ソースコードの段階で情報を保ったままの最適化を行う。 (リンク時の最適化をコンパイル時に行えても良い)
	
	基本方針として各ポイントで情報をコンパイラに与えたい

### エクスポートについて

モジュール外部へAPIを公開する仕組みは複数ある。
   
1. ヘッダーファイルに対応するソースコード群(実装)
   
    C的な
   
2. エクスポート情報のみを書いたソースコードをエントリポイントとする
	
	内部モジュール内のさらに公開するAPIをエクスポートしなおすファイルがある。
	
3. pubキーワードの導入
	
	モジュールの深くにあってもpubでエキスポート可能。

気分としては3>2>1

### モジュールについて雑多なこと

+ ファイル名はモジュール名にならない
+ ソースコード上にモジュール情報を書く
	+ 自動的に同名のモジュールを一つにまとめるかは未定。

## 契約とインターフェース
  
### インターフェース

+ パブリックAPIはコンパイル時にAPI情報が抽出され、ファイルに書き出す。
+ ファイルは、ライブラリ利用者が使用する。
+ API情報にはシグニチャと契約が記述される事が想定される。
+ ヒューマンリーダブルかは保留。

### 契約について
+ ヘッダーがあるならそれに書いてもいい。
+ API情報が抽出されるので、そこに出力される。
+ APIファイル利用者は、契約情報を取り出してコンパイルする。

+ 契約は関数/メソッドに外的に表明する。
+ 高階関数は考慮しない
+ 契約内ではピュアなメソッド呼び出しに制限したい
+ 契約はデバッグモードなら関数に直接組み込んでも良い
	
