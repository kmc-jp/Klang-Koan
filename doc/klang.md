+ unsafe ⇔ クラスの概念を越える。

----------

## 言語の要素
+ モジュール
+ 関数
+ クラス
+ 宣言
+ 演算子
+ 型・型修飾子
+ 式
+ 文・制御構文
+ 配列・ポインタ
+ コンセプト

## 型・型修飾子
+ 型の関するtype traitsやtamplateなどの型操作に関する機能はclassに対して適用される。
  primitiveには適用されない。
  型だと思うものはclassだけである。
  代わりにprimitiveなデータ型と同じ大きさのwrapper classを作り、対処する。
+ 型と修飾子は直行する概念。

## タプル
+ 縮約
  * ((I,((((I)),I))))
  * (I,(I,I))
  * 上は下に縮約される。それでもよいか？ よさそう
+ 組み込みのタプル型はテンプレート引数が1引数タプルだった場合のみ内側のタプルを取り出す。
+ X<int>とx<char>が等しくないようにT<U>とT<T<U>>が等しくなくなってしまうので、コンパイルマジックが必要になる。
+ f x というような関数呼び出しは許容しない。
+ 丸括弧の前には関数名・演算子・空のいずれかがある。
+ 関数呼び出しがあったら、引数をタプルだと思い処理する。既にタプルだった場合その渡す。
+ 暗黙のアンボクス
  * 1引数タプルは暗黙に型変換できる。tuple<int>はintになる。この挙動を__「やつす」__と呼ぶ。
  * swiftにも似たような挙動はある。
+ 夢のtupleと夢から覚めたtpuleの二つがある。夢から覚めたtupleはユーザーが勝手に作ったのでもよい。

## 演算子
+ Q: 1 > 2 = 3 > 4 はtrue?それとも型エラー?
  演算子の優先度の定義によりそう
  CとかRustはtrueだし、従ってほしい気分ではある
  \>=とかあるんだから同格でもいいも一説

## value type
+ lvalue rvalue xvalue prvalue ...
+ movable copyable

|          |       movable     |   not   |
|:--------:|:-----------------:|:-------:|
| copyable |       vector      | literal |
|   not    | unique_ptr thread |  mutex  |

## 型修飾子
+ 型とは直交する概念
+ 変更可能性と参照について導入
+ 変更可能性型修飾子
  * `immutable`: __
	変更不可能かつ、実行中に他のプログラムによって書き換えられることもない
  * `readonly`: __
	変更不可能だが、実行中に値が変わる場合がある
  * `mutable`
+ 参照について
  * `value`
  * `ref`

## 関数
+ 関数ポインタ型と抽象化された関数の二つ
  * グローバル関数は静的記憶域に保持されるラムダ式オブジェクト。
  * 関数(ラムダ式)を保持するテンプレートクラスが組み込みに必要。
	_callなどのメゾッドを持ち、これの呼び出しがdispatchされる。
  * このクラスが保持するprimitiveな関数ポインタの使いかた。
    - あとで考える。←Cで扱えるので、扱えなければ。
  * Callableコンセプトを満す。⇔_callメゾッドとしてもつ
  * 関数ポインタの型はCぐらい欲しい。

+ デフォルト引数は入れない。
+ 暗黙の型修飾子
  + 関数の引数
	+ 何も付けないと`immutable A&`
	+ `const`を付けると`const A&`
	+ `var`を付けると値渡し
  + 関数の戻り値
	+ 何も付けないと`immutable A`
	+ `const`を付けると`const A`
	+ 書き換えたい場合は`var`で返す。
	+ ただし、`f(int x, int y)->(int)`のシグニチャを持つメソッドは`f(var (int&, int&) xy)->(int)`と等価となるため、議論を要する。
+ RVOを前提として設計する
  + RVO: return value optimization. 返り値へのポインタを暗黙の引数として渡すことでコピーの回数を削減する最適化

## 契約
+ 契約内部では純粋なメソッド呼び出しのみに制限する仕組みが欲しい
+ 契約はデバッグビルドの際のみ関数内のプログラムとして挿入

## インターフェースファイル
+ コンパイル時に公開APIの情報をファイルに書き出す仕組みを導入する。
+ ファイルはライブラリ利用者が依存するプログラムのコンパイル時に利用する
+ シグニチャと契約が含まれているかも(未定)
+ ヒューマンリーダブルかは保留

## メモ
+ C++はmoveをデフォルトにすべきだった。
  + copyは明示すべき 特にvectorのようなcopyとmoveの挙動が異なる場合
+ mutableな参照は事故が多いので対処が必要
+ "intはユーザー定義型のように振舞え"
+ C++の後続を任せられる値の言語を目指す
+ Cの資産は欲しいけれど、C++の資産はそこまで欲しくない。テンプレート・オーバーロードが辛い
+ リスト内包表記はマクロでやる
+ *式年遷宮*
+ 意味論を考えてから構文を考える。
  + 構文は初め冗長にする。あとでもっと良いのを考える。
+ `ref`は`null`になるのはおかしい。もし`ref`が`null`をとれると、`ptr`と`ref`がともに`null`をとれることになってしまい、`null`の型がおかしくなる。
+ シグニチャがドキュメントになるようにしたい。ヘッダファイルの様なものが有るならそれがドキュメントになるようにする。
