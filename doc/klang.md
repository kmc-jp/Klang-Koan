+ unsafe ⇔ クラスの概念を越える。

----------

## 言語の要素
+ モジュール
+ 関数
+ クラス
+ 宣言
+ 演算子
+ 型・型修飾子
+ 式
+ 文・制御構文
+ 配列・ポインタ
+ コンセプト

## 関数
+ 関数ポインタ型と抽象化された関数の二つ
  * グローバル関数は静的記憶域に保持されるラムダ式オブジェクト。
  * 関数(ラムダ式)を保持するテンプレートクラスが組み込みに必要。
	_callなどのメゾッドを持ち、これの呼び出しがdispatchされる。
  * このクラスが保持するprimitiveな関数ポインタの使いかた。
    - あとで考える。←Cで扱えるので、扱えなければ。
  * Callableコンセプトを満す。⇔_callメゾッドとしてもつ
  * 関数ポインタの型はCぐらい欲しい。

## 型・型修飾子
+ 型の関するtype traitsやtamplateなどの型操作に関する機能はclassに対して適用される。
  primitiveには適用されない。
  型だと思うものはclassだけである。
  代わりにprimitiveなデータ型と同じ大きさのwrapper classを作り、対処する。
+ 型と修飾子は直行する概念。

## タプル
+ 縮約
  * ((I,((((I)),I))))
  * (I,(I,I))
  * 上は下に縮約される。それでもよいか？ よさそう
+ 組み込みのタプル型はテンプレート引数が1引数タプルだった場合のみ内側のタプルを取り出す。
+ X<int>とx<char>が等しくないようにT<U>とT<T<U>>が等しくなくなってしまうので、コンパイルマジックが必要になる。
+ f x というような関数呼び出しは許容しない。
+ 丸括弧の前には関数名・演算子・空のいずれかがある。
+ 関数呼び出しがあったら、引数をタプルだと思い処理する。既にタプルだった場合その渡す。
+ 暗黙のアンボクス
  * 1引数タプルは暗黙に型変換できる。tuple<int>はintになる。この挙動を__「やつす」__と呼ぶ。
  * swiftにも似たような挙動はある。
+ 夢のtupleと夢から覚めたtpuleの二つがある。夢から覚めたtupleはユーザーが勝手に作ったのでもよい。

## 関数
+ 関数宣言の形式は変数宣言の形式を決定する時に決める。一貫性を保つ。
+ デフォルト引数は入れない。
+ f(1,2,3)はf((1,2,3))に変換される。
+ x=(1,2,3)の場合f(x) ⇔ ((1,2,3))
+ f(x:(I, I, I)) と f(x:I, y:I, z:I) を区別したいか？
  * 右は左のシンタックスシュガー

## 演算子
+ Q: 1 > 2 = 3 > 4 はtrue?それとも型エラー?
  演算子の優先度の定義によりそう
  CとかRustはtrueだし、従ってほしい気分ではある
  \>=とかあるんだから同格でもいいも一説
