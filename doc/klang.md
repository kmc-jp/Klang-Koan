+ unsafe ⇔ クラスの概念を越える。

----------

## 言語の要素
+ モジュール
+ 関数
+ クラス
+ 宣言
+ 演算子
+ 型・型修飾子
+ 式
+ 文・制御構文
+ 配列・ポインタ
+ コンセプト

## 関数
+ 関数ポインタ型と抽象化された関数の二つ
  * グローバル関数は静的記憶域に保持されるラムダ式オブジェクト。
  * 関数(ラムダ式)を保持するテンプレートクラスが組み込みに必要。
	_callなどのメゾッドを持ち、これの呼び出しがdispatchされる。
  * このクラスが保持するprimitiveな関数ポインタの使いかた。
    - あとで考える。←Cで扱えるので、扱えなければ。
  * Callableコンセプトを満す。⇔_callメゾッドとしてもつ
  * 関数ポインタの型はCぐらい欲しい。

## 型・型修飾子
+ 型の関するtype traitsやtamplateなどの型操作に関する機能はclassに対して適用される。
  primitiveには適用されない。
  型だと思うものはclassだけである。
  代わりにprimitiveなデータ型と同じ大きさのwrapper classを作り、対処する。
+ 型と修飾子は直行する概念。

## タプル
+ 縮約
  * ((I,((((I)),I))))
  * (I,(I,I))
  * 上は下に縮約される。それでもよいか？ よさそう
+ 組み込みのタプル型はテンプレート引数が1引数タプルだった場合のみ内側のタプルを取り出す。
+ X<int>とx<char>が等しくないようにT<U>とT<T<U>>が等しくなくなってしまうので、コンパイルマジックが必要になる。
+ f x というような関数呼び出しは許容しない。
+ 丸括弧の前には関数名・演算子・空のいずれかがある。
+ 関数呼び出しがあったら、引数をタプルだと思い処理する。既にタプルだった場合その渡す。
+ 暗黙のアンボクス
  * 1引数タプルは暗黙に型変換できる。tuple<int>はintになる。この挙動を__「やつす」__と呼ぶ。
  * swiftにも似たような挙動はある。
+ 夢のtupleと夢から覚めたtpuleの二つがある。夢から覚めたtupleはユーザーが勝手に作ったのでもよい。

## 関数
+ 関数宣言の形式は変数宣言の形式を決定する時に決める。一貫性を保つ。
+ デフォルト引数は入れない。
+ f(1,2,3)はf((1,2,3))に変換される。
+ x=(1,2,3)の場合f(x) ⇔ ((1,2,3))
+ f(x:(I, I, I)) と f(x:I, y:I, z:I) を区別したいか？
  * 右は左のシンタックスシュガー

## 演算子
+ Q: 1 > 2 = 3 > 4 はtrue?それとも型エラー?
  演算子の優先度の定義によりそう
  CとかRustはtrueだし、従ってほしい気分ではある
  \>=とかあるんだから同格でもいいも一説

## 型修飾子
+ 型とは直交する概念
+ ref immutable
+ lvalue rvalue xvalue prvalue ...
+ movable copyable

|          |       movable     |   not   |
|:--------:|:-----------------:|:-------:|
| copyable |       vector      | literal |
|   not    | unique_ptr thread |  mutex  |

## メモ
+ C++はmoveをデフォルトにすべきだった。
  + copyは明示すべき 特にvectorのようなcopyとmoveの挙動が異なる場合
+ mutableな参照は事故が多いので対処が必要
+ "intはユーザー定義型のように振舞え"
+ C++の後続を任せられる値の言語を目指す
+ Cの資産は欲しいけれど、C++の資産はそこまで欲しくない。テンプレート・オーバーロードが辛い
+ リスト内包表記はマクロでやる
+ *式年遷宮*
+ 意味論を考えてから構文を考える。
  + 構文は初め冗長にする。あとでもっと良いのを考える。
+ `ref`は`null`になるのはおかしい。もし`ref`が`null`をとれると、`ptr`と`ref`がともに`null`をとれることになってしまい、`null`の型がおかしくなる。
+ シグニチャがドキュメントになるようにしたい。ヘッダファイルの様なものが有るならそれがドキュメントになるようにする。
|:-----------:|:--------------:|:------------:|
|      A      | read only view |   const A&   |
| immutable A |                | immutable A& |
|    var A    |                |       A      |

+ 関数の引数
  + 何も付けないと`const A&`
  + `immutable`と付けると`immutable A&`
  + `var`を付けると値渡し
+ 関数の戻り値
  + 書き換えたい場合は`var`で返す。
  + 参照で返すにしても内部実装としては実体で返しているはず。
