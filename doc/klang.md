
unsafe ⇔ クラスの概念を越える。
==========

#言語の要素
+モジュール
+関数
+クラス
+宣言
+演算子
+型・型修飾子
+式
+文・制御構文
+配列・ポインタ
+コンセプト



#関数
+関数ポインタ型と抽象化された関数の二つ
 *グローバル関数は静的記憶域に保持されるラムダ式オブジェクト。
 *関数(ラムダ式)を保持するテンプレートクラスが組み込みに必要。 _callなどのメゾッドを持ち、これの呼び出しがdispatchされる。
 *このクラスが保持するprimitiveな関数ポインタの使いかた。
  -あとで考える。←Cで扱えるので、扱えなければ。
 *Callableコンセプトを満す。⇔_callメゾッドとしてもつ
 *関数ポインタの型はCぐらい欲しい。

#型・型修飾子
+型の関するtype traitsやtamplateなどの型操作に関する機能はclassに対して適用される。primitiveには適用されない。型だと思うものはclassだけである。代わりにprimitiveなデータ型と同じ大きさのwrapper classを作り、対処する。
+型と修飾子は直行する概念。



#タプル
+縮約
 *((I,((((I)),I))))
 *(I,(I,I))
 *上は下に縮約される。それでもよいか？ よさそう


+組み込みのタプル型はテンプレート引数が1引数タプルだった場合のみ内側のタプルを取り出す。
+X<int>とx<char>が等しくないようにT<U>とT<T<U>>が等しくなくなってしまうので、コンパイルマジックが必要になる。
+f x というような関数呼び出しは許容しない。
+丸括弧の前には関数名・演算子・空のいずれかがある。
+関数呼び出しがあったら、引数をタプルだと思い処理する。既にタプルだった場合その渡す。


+暗黙のアンボクス
 *1引数タプルは暗黙に型変換できる。tuple<int>はintになる。この挙動を__「やつす」__と呼ぶ。
 *swiftにも似たような挙動はある。

+夢のtupleと夢から覚めたtpuleの二つがある。夢から覚めたtupleはユーザーが勝手に作ったのでもよい。


#関数
+関数宣言の形式は変数宣言の形式を決定する時に決める。一貫性を保つ。
+デフォルト引数は入れない。

+f(1,2,3)はf((1,2,3))に変換される。
+x=(1,2,3)の場合f(x) ⇔ ((1,2,3))
+f(x:(I, I, I)) と f(x:I, y:I, z:I) を区別したいか？
 *右は左のシンタックスシュガー
